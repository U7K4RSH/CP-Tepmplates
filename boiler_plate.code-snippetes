{
	"C++ Template With Aliases and Fast IO": {
		"scope": "cpp",
		"prefix": "init",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"#define lli long long int",
			"#define ll long long",
			"#define vv vector<vector<lli>>",
			"#define V vector<lli>",
			"#define no cout<<\"NO\\n\"",
			"#define yes cout<<\"YES\\n\"",
			"",
			"int main(){",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"",
			"    $0",
			"",
			"    return 0;",
			"}"
		],
		"description": "C++ competitive programming template with fast I/O and common type definitions"
	},
	"Test Cases": {
		"scope": "cpp",
		"prefix": "eazy",
		"body": [
			"lli t;",
			"cin >> t;",
			"for (size_t i = 0; i < t; i++)",
			"{",
			"    lli n;",
			"    cin >> n;",
			"    vector<lli> a(n);",
			"    for (size_t i = 0; i < n; i++)",
			"    {",
			"        cin >> a[i];",
			"    }",
			"    $0",
			"}"
		],
		"description": "Read multiple test cases and input arrays"
	},
	"Modular": {
    "scope": "cpp",
    "prefix": "modular",
    "body": [
      "const lli mod = 998244353;",
      "#define xxx Modular<mod>",
      "template <int MOD=mod>",
      "struct Modular {",
      "    int value;",
      "    static const int MOD_value = MOD;",
      "    Modular(long long v = 0) { value = v % MOD; if (value < 0) value += MOD;}",
      "    Modular(long long a, long long b) : value(0){ *this += a; *this /= b;}",
      "    Modular& operator+=(Modular const& b) {value += b.value; if (value >= MOD) value -= MOD; return *this;}",
      "    Modular& operator-=(Modular const& b) {value -= b.value; if (value < 0) value += MOD;return *this;}",
      "    Modular& operator*=(Modular const& b) {value = (long long)value * b.value % MOD;return *this;}",
      "    friend Modular mexp(Modular a, long long e) {",
      "        Modular res = 1; while (e) { if (e&1) res *= a; a *= a; e >>= 1; }",
      "        return res;",
      "    }",
      "    friend Modular inverse(Modular a) { return mexp(a, MOD - 2); }",
      "    Modular& operator/=(Modular const& b) { return *this *= inverse(b); }",
      "    friend Modular operator+(Modular a, Modular const b) { return a += b; }",
      "    friend Modular operator-(Modular a, Modular const b) { return a -= b; }",
      "    friend Modular operator-(Modular const a) { return 0 - a; }",
      "    friend Modular operator*(Modular a, Modular const b) { return a *= b; }",
      "    friend Modular operator/(Modular a, Modular const b) { return a /= b; }",
      "    friend std::ostream& operator<<(std::ostream& os, Modular const& a) {return os << a.value;}",
      "    friend bool operator==(Modular const& a, Modular const& b) {return a.value == b.value;}",
      "    friend bool operator!=(Modular const& a, Modular const& b) {return a.value != b.value;}",
      "};"
    ],
    "description": "Modular arithmetic struct with basic operations and inverse using Fermat's Little Theorem"
  },
  "Segment Tree": {
    "scope": "cpp",
    "prefix": "seg",
    "body": [
      "class SegTree",
      "{",
      "private:",
      "    lli n, def;",
      "    vector<lli> tree, lazy, pending;",
      "    lli (*combine)(lli obj1, lli obj2);",
      "",
      "    void build(lli ind, vector<lli> &a, lli i, lli j)",
      "    {",
      "        if (i == j)",
      "        {",
      "            tree[ind] = a[i];",
      "            return;",
      "        }",
      "        lli mid = (i + j) / 2;",
      "        build(2 * ind + 1, a, i, mid);",
      "        build(2 * ind + 2, a, mid + 1, j);",
      "        tree[ind] = combine(tree[2 * ind + 1], tree[2 * ind + 2]);",
      "    }",
      "",
      "    lli query(lli ind, lli i, lli j, lli l, lli r)",
      "    {",
      "        if (pending[ind])",
      "        {",
      "            apply(ind, i, j);",
      "        }",
      "        if (l > j || r < i)",
      "        {",
      "            return def;",
      "        }",
      "        if (i >= l && j <= r)",
      "        {",
      "            return tree[ind];",
      "        }",
      "        lli mid = (i + j) / 2;",
      "        return combine(query(2 * ind + 1, i, mid, l, r), query(2 * ind + 2, mid + 1, j, l, r));",
      "    }",
      "",
      "    void update(lli ind, lli i, lli j, lli pos, lli val)",
      "    {",
      "        if (pending[ind])",
      "        {",
      "            apply(ind, i, j);",
      "        }",
      "        if (pos > j || pos < i)",
      "        {",
      "            return;",
      "        }",
      "        if (i == j)",
      "        {",
      "            tree[ind] = val;",
      "            return;",
      "        }",
      "        lli mid = (i + j) / 2;",
      "        update(2 * ind + 1, i, mid, pos, val);",
      "        update(2 * ind + 2, mid + 1, j, pos, val);",
      "        tree[ind] = combine(tree[2 * ind + 1], tree[2 * ind + 2]);",
      "    }",
      "",
      "    void rangeupdate(lli ind, lli i, lli j, lli l, lli r, lli val)",
      "    {",
      "        if (pending[ind])",
      "        {",
      "            apply(ind, i, j);",
      "        }",
      "        if (i > r || j < l)",
      "        {",
      "            return;",
      "        }",
      "        if (i >= l && j <= r)",
      "        {",
      "            pending[ind] = 1;",
      "            lazy[ind] = val;",
      "            apply(ind, i, j);",
      "            return;",
      "        }",
      "        lli mid = (i + j) / 2;",
      "        rangeupdate(2 * ind + 1, i, mid, l, r, val);",
      "        rangeupdate(2 * ind + 2, mid + 1, j, l, r, val);",
      "        tree[ind] = combine(tree[2 * ind + 1], tree[2 * ind + 2]);",
      "    }",
      "",
      "    void apply(lli ind, lli l, lli r)",
      "    {",
      "        if (l != r)",
      "        {",
      "            pending[2 * ind + 1] = 1;",
      "            pending[2 * ind + 2] = 1;",
      "            lazy[2 * ind + 1] = lazy[ind];",
      "            lazy[2 * ind + 2] = lazy[ind];",
      "        }",
      "        tree[ind] = lazy[ind];",
      "        lazy[ind] = 0;",
      "        pending[ind] = 0;",
      "    }",
      "",
      "public:",
      "    SegTree(vector<lli> a, lli def, lli (*combine)(lli obj1, lli obj2))",
      "    {",
      "        this->n = a.size();",
      "        this->def = def;",
      "        tree.resize(4 * n, def);",
      "        lazy.resize(4 * n, 0);",
      "        pending.resize(4 * n, 0);",
      "        this->combine = combine;",
      "        build(0, a, 0, n - 1);",
      "    }",
      "",
      "    lli query(lli l, lli r)",
      "    {",
      "        if (r < l)",
      "        {",
      "            return 0;",
      "        }",
      "        return query(0, 0, n - 1, l, r);",
      "    }",
      "",
      "    void update(lli pos, lli val)",
      "    {",
      "        update(0, 0, n - 1, pos, val);",
      "    }",
      "",
      "    void rangeupdate(lli l, lli r, lli val)",
      "    {",
      "        rangeupdate(0, 0, n - 1, l, r, val);",
      "    }",
      "};"
    ],
    "description": "Segment Tree class with range updates, lazy propagation, and custom combine function"
  }
}
